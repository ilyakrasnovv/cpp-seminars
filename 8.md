# 8

## mutable

Иногда возникает ситуация, когда мы хотим изменять состояние объекта своего класса `C` даже в том случае, когда у переменной тип `const C` и нам запрещено что-либо делать. Как известно, нельзя снимать `const` с переменной
если объект под ней изначально был константным. Что же делать?

Естественно, придумано как сделать исключение из правил - ключевое слово `mutable`. Это квалификатор типа, такой же как и `const`, но с противоположным значением: переменная _всегда_ должна быть изменяемой. Использовать это
ключевое слово можно только для полей (то есть просто переменную где-то в функции создать нельзя), ну и естественно `mutable` не может быть написан одновременно с `const` (все эти случаи - CE, убедитесь сами).

**Пример:**
```c++
#include <iostream>

class C {
public:
    void foo() const {
        ++foo_count_;
    }

    std::size_t fooCount() const {
        return foo_count_;
    }
private:
    mutable std::size_t foo_count_{0};
};

int main() {
    const C c;
    c.foo();
    c.foo();
    std::cout << c.fooCount() << std::endl;  // 2
}
```

**Вопрос:** а когда такое вообще нужно, зачем это использовать?

**Ответ:** например, любая структура с кэшированием: они перестраивают своё состояние в зависимости от запросов, чтобы отвечать на них эффективнее. Яркий пример - это splay-tree. Другим примером можно считать логирование,
когда мы хотим сохранять куда-то информацию о действиях пользователя со структурой.

## static поля и методы класса

Поля и методы, по умолчанию, _привязаны к объекту_. То есть, у каждого объекта свои собственные поля со своими значениями. Изменив `obj1`, мы не затронем никак `obj2`. А методы, в свою очередь, всегда получают объект как
параметр функции в виде указателя `this`, что позволяет им (как минимум) модифицировать объекты.

Но бывают и другие ситуации:
 - Хочется написать вспомогательную функцию для класса, которая нигде больше не нужна (например, подставлять какой-то указатель по умолчанию вместо `nullptr`. Обернули эту логику в функцию, чтобы не копипастить)
 - Делить информацию между всеми объектами (например, так можно посчитать число живых объектов одного типа во всей программе)

Для реализации таких идей есть ключевое слово `static`: можно делать статические поля и методы.

Статические поля принадлежат _всему классу_, а не какому-то объекту.

**Важно:** инициализация статических _неконстантных_ переменных должна происходит вне класса. Начиная с C++17, это правило можно обойти, добавив квалификатор `inline` к переменной.

**Пример:**
```c++
struct S {
    int x = 0;  // owned by object
    static int y;  // owned by class
};

int S::y = 10;  // static member initialization

int main() {
    S s1;
    S s2;

    s1.x = 3;

    std::cout << s1.x << ' ' << s2.x << std::endl;   // 3 0
    
    s1.y = 10;

    std::cout << s1.y << ' ' << s2.y << std::endl;  // 10 10

    S::y = 5;  // more precise and conventional way

    std::cout << s1.y << ' ' << s2.y << std::endl;   // 5 5
}
```

Статические методы не имеют привязки ни к какому объекту, соответсвенно у них нет никакого неявного аргумента `this`. Они ничем не отличаются от дружественных функций в вопросе доступа к деталям класса. Основное различие
в том, что дружественная функция не принадежит области видимости класса, а статический метод - абсолютно да.

**Пример:**

```c++
class C {
public:
    C& operator+=(const C& rhs) {
        x_ = _add(x_, rhs.x_);
        return *this;
    }
private:
    static unsigned _add(unsigned a, unsigned b) {
        while (a > 0) {
            --a;
            ++b;
        }
        return b;
    }

private:
    unsigned x_;
};
```

## Перегрузка оператора приведения типа (Пользовательсие конверсии)

Помимо уже известных конверсий стандартных типов (array-to-pointer, integer promotion, etc.) конечно же можно определять конверсии для своих классов.

**Пример:**
```c++
class C {
public:
    C(int x) : x_{x} {}

    operator int() {
        return x_;
    }
private:
    int x_;
};

int main() {
    C c1(10);
    c1 + 50;  // equivalent to 10 + 50
}
```

**Замечание:** конструкторы класса, вообще говоря, тоже можно воспринимать как оператор конверсии _в данный класс_. Соответственно то, что мы в действительности называем оператором конверсии, позволяет задать конверсию
_из данного класса куда-то_.

**Замечание:** пользовательские операторы конверсии участвуют в выборе при неявной конверсии и при `static_cast` так же, как и все остальные. При этом, при неявной конверсии есть [определённый порядок, в котором рассматриваются
операторы](https://en.cppreference.com/w/cpp/language/implicit_conversion)

Отдельно стоит рассмотреть ситуацию, когда определяется оператор конверсии в _ссылочный тип_. В таком случае, не будет идти речь о создании какого-либо временного объекта. Память текущего объекта должна быть как-либо представлена в указанный
ссылочный тип.

**Пример:**
```c++
struct A {
    float x;
    float y;
};

class B {
public:
    B(float x, float y, int b) : a_{.x = x, .y = y}, b_{b} {}

    operator A&() {
        return a_;  // returning reference to inner A object
    }
private:
    A a_;
    int b_;
};
```

## explicit

Явное лучше неявного. И есть много ситуаций, когда запрет неявного каста спасает программиста от случайной ошибки, которую потом можно искать часами. Самый простой пример - функция, принимающая координаты как отдельные параметры: 
```c++
double calculateLength(int x, int y, int z) {
    // some code
}
```
Ничто не останавливает программиста от ситуации, когда он перепутает координаты в 3 часа ночи. Чтобы избежать этого, можно создать класс-обёртку для каждой координаты с запретом неявной конверсии одного в другое. Будет
что-то в духе такого:
```c++
double calculateLength(X x, Y y, Z z) {
    // some code
}
```

Но как же добиться запрета неявной конверсии? Для этого есть ключевое слово `explicit`. Его можно писать как перед конструкторами, так и перед операторами конверсии:
```c++
class X {
public:
    explicit X(int x) : x_{x} {}

    explicit operator Y() {
        return Y(x_);
    }

    explicit operator Z() {
        return Z(x_);
    }

    operator int() {  // actually why not?
        return x_;
    }
private:
    int x_;
};
```

**Замечание:** считается хорошим тоном делать конструкторы от 1 аргумента всегда `explicit`. О том, какими интересными образами можно прострелить себе колено, можно почитать
[этот блог](https://quuxplusone.github.io/blog/2023/04/08/most-ctors-should-be-explicit/)

## Контекстная конверсия

В C++ есть пара конструкций, в которых ожидаемый тип зафиксирован на уровне языка. Это, как правило, различные условия

**Пример:**
```c++
if (cond) {  // cond is bool
}

while (cond) {}  // cond is bool
```

В такие места можно ставить выражения любого типа, но тогда этот тип _должен уметь конвертироваться в `bool`_. Произойдёт _контекстная конверсия_, которая не требует явного указания преобразования (этим она абсолютно сродне
неявной конверсии). Ключевое слово `explicit` не влияет на эти конверсии.

**Пример:**
```c++
void foo(int* ptr) {
    if (ptr) {
        // ptr != nullptr
    } else {
        // ptr == nullptr
    }
}
```

**Пример:**
```c++
#include <iostream>

int main() {
    int n;

    while (std::cin >> n) {  // true until EOF
    }
}
```

## Указатели на члены класса

Прости, Господи, нас грешных... В C++ есть отдельная, специальная каста указателей - указатели на поля и методы класса.

**Пример:**
```c++
class C {
public:
    void f(int) {
    }

    int x;
};

int main() {
    void (C::*fun_ptr)(int) = nullptr;  // pointer to a method of class C with signature void(int)
    fun_ptr = &C::f;
    C c1;
    C* c1_ptr = &c1;

    (c1.*fun_ptr)(10);  // operator.*  // Yes, two symbols!
    (c1_ptr->*fun_ptr)(5);  // operator->*  // Oh yeah, three symbols!!!

    int (C::*field_ptr) = nullptr;  // pointer to a field of class C with type int
    field_ptr = &C::x;
    c1.*field_ptr;  // that's crazy
}
```

Особенности на синтаксисе не заканчиваются. Размер указателя на член класса в 2 раза превышает размер обычного указателя (проверьте сами), что ставит крест на возможности преобразовать такой указатель, скажем, в `void*`.

**Замечание:** пока что можно думать, что этот указатель - это какой-то мистический сдвиг от начала класса до начала поля. Истина откроется сильно позже.

**Fun fact:** вывод указателя на метод через `std::cout` приводит к появлению 0, если это `nullptr`, и 1 иначе.

## enum & enum class

Enum - это специальный пользовательский тип, который полезен когда нужно выделить какое-то конечное число значений (флажки, метки и пр.). Эта идея существует ещё со времён языка C.

**Пример:** 
```c
enum Status {
    kOk,
    kWait,
    kError
};

int main() {
    // some code
    while (true) {
        // some input
        switch (status) {
            case Status::kOk:
                // some code
                break;
            case Status::kWait:
                // some code
                break;
            case Status::kError:
                // some code
                break
        }
    }
}
```

`enum` не является новым типом в полной мере. На деле, есть _низлежащий тип (underlying type)_, который используется для хранения реальных значений элементов. Его можно указать явно, через двоеточие после имени перечисления:
`enum Status : int { /*enum value here*/ };`

Также стоит отметить, что по умолчанию значения переменных `enum`'а растут от нуля с добавлением единицы на каждом шаге. Можно указать значение какой-то переменной явно, тогда следующая последовательность сдвинется:
```c++
enum Status {
    kOk = 3,
    kWait,  // now 4
    kError  // now 5
};
```

**Замечание:** `enum`'у можно указать _низлежащий тип_, который используется для хранения реальных значений элементов. Делается это так: `enum Status : int { /*enum values here*/};`

Казалось бы, эта структура должна быть тупой как пробка, но в C всё же есть нюансы:
 1. Фактически, `enum` - это просто набор именованных констант. Их можно было указывать и без квалифицированного имени
 2. Если не указан явно тип, находящийся под `enum`, то компилятор не даёт никаких гарантий на него, кроме той, что этот тип способен вместить все значения этого `enum`'a

Поэтому в C++ по итогу переизобрели этот механизм, сделав свой `enum class`. К слову, старый `enum` называют _unscoped enumeration_, ну а свежий - _scoped enumeration_. Полные гарантии каждого механизма можно почитать
[тут](https://en.cppreference.com/w/cpp/language/enum).

**Fun fact:** можно писать `enum struct`, разницы никакой нет

Обе проблемы в C++ решены... но всё же иногда хочется работать с элементами `enum class`'а как просто с числами. В этот момент есть 3 пути:
 1. Страдать с кучей `static_cast`'ов
 2. Перейти обратно на `enum`
 3. Определить операторы над `enum class`'ом.

**Пример:** 
```c++
namespace fl {
    enum class TokenType : int {
        kNothing = 0b00,
        kTerminal = 0b01,
        kNonterminal = 0b10
    };

    TokenType operator&(TokenType a, TokenType b);
    TokenType operator^(TokenType a, TokenType b);
    TokenType operator|(TokenType a, TokenType b);


    void assignXor(fl::TokenType& ref, fl::TokenType type);
    void assignOr(fl::TokenType& ref, fl::TokenType type);

    // and the implementation is somewhere 
}  // namespace fl
```

**Замечание:** ещё одной из интересных причин использовать `enum class`'ы является то, что компилятор будет давать предупреждение, если в `switch`-конструкции с данным `enum class`'ом не рассмотрены все случаи. Для `enum`
такого нет.
